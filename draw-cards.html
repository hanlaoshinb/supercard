<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¡”ç½—ç‰ŒæŠ½å– - å¡”ç½—ç‰Œåœ¨çº¿å åœ</title>
    <meta name="description" content="æŠ½å–æ‚¨çš„å¡”ç½—ç‰Œï¼Œè·å¾—ä¸“ä¸šå¡”ç½—ç‰Œå åœè§£è¯»ï¼Œäº†è§£æ‚¨çš„çˆ±æƒ…ã€äº‹ä¸šå’Œäººç”Ÿèµ°å‘ã€‚">
    <style>
        :root {
            --primary-color: #7D56F4;
            --secondary-color: #FFC107;
            --dark: #1D1D1F;
            --light: #F5F5F7;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'SF Pro Display', 'SF Pro Text', 'Helvetica Neue', 'Helvetica', 'Arial', sans-serif;
            background-color: var(--light);
            color: var(--dark);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            line-height: 1.6;
        }
        
        header {
            background-color: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            position: sticky;
            top: 0;
            z-index: 50;
            border-bottom: 1px solid #eee;
        }
        
        .header-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0.75rem 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: bold;
            font-size: 1.25rem;
            color: var(--dark);
            text-decoration: none;
        }
        
        main {
            flex: 1;
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
            padding: 1.5rem 1rem;
        }
        
        .question-container {
            background-color: white;
            border-radius: 12px;
            padding: 1rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        .question-label {
            font-size: 0.875rem;
            color: #666;
            margin-bottom: 0.25rem;
        }
        
        .question-text {
            font-weight: 500;
        }
        
        .canvas-container {
            width: 100%;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        #tarotCanvas {
            background: linear-gradient(135deg, #1a1a2e, #16213e, #1a1a2e);
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            margin-bottom: 1rem;
        }
        
        .instructions {
            text-align: center;
            margin-bottom: 1.5rem;
            color: var(--primary-color);
            font-weight: 500;
        }
        
        .instructions span {
            color: #8833dd;
            font-weight: 600;
        }
        
        #resultButton {
            display: none;
            background: linear-gradient(to right, var(--primary-color), #8833dd);
            color: white;
            border: none;
            padding: 0.75rem 2rem;
            border-radius: 8px;
            font-weight: 500;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(125, 86, 244, 0.2);
            transition: all 0.3s ease;
        }
        
        #resultButton:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(125, 86, 244, 0.3);
        }
        
        footer {
            background-color: var(--dark);
            color: white;
            padding: 3rem 1rem;
        }
        
        .footer-container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .footer-grid {
            display: grid;
            grid-template-columns: repeat(1, 1fr);
            gap: 2rem;
        }
        
        @media (min-width: 768px) {
            .footer-grid {
                grid-template-columns: repeat(4, 1fr);
            }
        }
        
        .footer-heading {
            font-size: 1.125rem;
            font-weight: 600;
            margin-bottom: 1rem;
        }
        
        .footer-text {
            color: #aaa;
            font-size: 0.875rem;
        }
        
        .footer-links {
            list-style: none;
        }
        
        .footer-links li {
            margin-bottom: 0.5rem;
        }
        
        .footer-links a {
            color: #aaa;
            text-decoration: none;
            font-size: 0.875rem;
            transition: color 0.2s;
        }
        
        .footer-links a:hover {
            color: white;
        }
        
        .footer-copyright {
            border-top: 1px solid #333;
            margin-top: 2rem;
            padding-top: 2rem;
            text-align: center;
            color: #aaa;
            font-size: 0.875rem;
        }
    </style>
</head>
<body>
    <!-- å¯¼èˆªæ  -->
    <header>
        <div class="header-container">
            <a href="/" class="logo">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" xmlns="http://www.w3.org/2000/svg" style="color: #7D56F4">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zm0 0h12a2 2 0 002-2v-4a2 2 0 00-2-2h-2.343M11 7.343l1.657-1.657a2 2 0 012.828 0l2.829 2.829a2 2 0 010 2.828l-8.486 8.485M7 17h.01"></path>
                </svg>
                <span>Tarotap</span>
            </a>
        </div>
    </header>

    <!-- ä¸»è¦å†…å®¹ -->
    <main>
        <!-- ç”¨æˆ·é—®é¢˜æ˜¾ç¤º -->
        <div class="question-container">
            <div class="question-label">æ‚¨çš„é—®é¢˜</div>
            <p id="user-question" class="question-text">åŠ è½½ä¸­...</p>
        </div>
        
        <!-- Canvas æŠ½ç‰ŒåŒºåŸŸ -->
        <div class="canvas-container">
            <canvas id="tarotCanvas" width="800" height="600"></canvas>
            <p id="instructions" class="instructions">
                è¯·ä»ç‰Œå †ä¸­æŠ½å–ä¸‰å¼ ç‰Œï¼Œåˆ†åˆ«ä»£è¡¨<span>è¿‡å»</span>ã€<span>ç°åœ¨</span>å’Œ<span>æœªæ¥</span>
            </p>
            <button id="resultButton">æŸ¥çœ‹å åœç»“æœ</button>
        </div>
    </main>

    <!-- é¡µè„šç®€åŒ–ç‰ˆ -->
    <footer>
        <div class="footer-container">
            <div class="footer-grid">
                <div>
                    <h3 class="footer-heading">å…³äºæˆ‘ä»¬</h3>
                    <p class="footer-text">Tarotapæ˜¯ä¸€ä¸ªä¸“ä¸šçš„åœ¨çº¿å¡”ç½—ç‰Œå åœå¹³å°ï¼Œè‡´åŠ›äºé€šè¿‡ç°ä»£ç§‘æŠ€ä¸å¤è€æ™ºæ…§çš„ç»“åˆï¼Œä¸ºç”¨æˆ·æä¾›å‡†ç¡®ã€ä¾¿æ·çš„å¡”ç½—ç‰Œè§£è¯»æœåŠ¡ã€‚</p>
                </div>
                
                <div>
                    <h3 class="footer-heading">å¿«é€Ÿé“¾æ¥</h3>
                    <ul class="footer-links">
                        <li><a href="#">é¦–é¡µ</a></li>
                        <li><a href="#">å¡”ç½—ç‰Œå åœ</a></li>
                        <li><a href="#">ä¼šå‘˜æœåŠ¡</a></li>
                        <li><a href="#">å­¦ä¹ ä¸­å¿ƒ</a></li>
                    </ul>
                </div>
                
                <div>
                    <h3 class="footer-heading">è”ç³»æˆ‘ä»¬</h3>
                    <p class="footer-text">contact@aihinto.com</p>
                </div>
            </div>
            
            <div class="footer-copyright">
                <p>&copy; 2025 Tarotap. ç‰ˆæƒæ‰€æœ‰</p>
            </div>
        </div>
    </footer>

    <!-- Canvasç»˜å›¾å’ŒåŠ¨ç”»è„šæœ¬ -->
    <script>
        // ä»URLè·å–æŸ¥è¯¢å‚æ•°
        const urlParams = new URLSearchParams(window.location.search);
        const master = urlParams.get('master');
        const question = urlParams.get('question');
        const spread = urlParams.get('spread');
        
        // æ˜¾ç¤ºç”¨æˆ·é—®é¢˜
        const userQuestionEl = document.getElementById('user-question');
        if (question) {
            userQuestionEl.textContent = decodeURIComponent(question);
        } else {
            userQuestionEl.textContent = "æ²¡æœ‰æä¾›é—®é¢˜";
        }
        
        // å¡”ç½—ç‰Œæ•°æ®
        const tarotCards = [
            {name: "æ„šè€…", symbol: "âœ¨"},
            {name: "é­”æœ¯å¸ˆ", symbol: "ğŸ”®"},
            {name: "å¥³ç¥­å¸", symbol: "ğŸŒ™"},
            {name: "å¥³çš‡", symbol: "ğŸŒº"},
            {name: "çš‡å¸", symbol: "ğŸ‘‘"},
            {name: "æ•™çš‡", symbol: "âœï¸"},
            {name: "æ‹äºº", symbol: "â¤ï¸"},
            {name: "æˆ˜è½¦", symbol: "âš”ï¸"},
            {name: "åŠ›é‡", symbol: "ğŸ¦"},
            {name: "éšè€…", symbol: "ğŸ”¦"},
            {name: "å‘½è¿ä¹‹è½®", symbol: "ğŸ¡"},
            {name: "æ­£ä¹‰", symbol: "âš–ï¸"},
            {name: "æ‚¬åŠè€…", symbol: "ğŸ™ƒ"},
            {name: "æ­»ç¥", symbol: "ğŸ’€"},
            {name: "èŠ‚åˆ¶", symbol: "â³"},
            {name: "æ¶é­”", symbol: "ğŸ‘¹"},
            {name: "å¡”", symbol: "ğŸ—¼"},
            {name: "æ˜Ÿæ˜Ÿ", symbol: "â­"},
            {name: "æœˆäº®", symbol: "ğŸŒ™"},
            {name: "å¤ªé˜³", symbol: "â˜€ï¸"},
            {name: "å®¡åˆ¤", symbol: "ğŸ“¯"},
            {name: "ä¸–ç•Œ", symbol: "ğŸŒ"}
        ];
        
        // Canvasè®¾ç½®
        const canvas = document.getElementById('tarotCanvas');
        const ctx = canvas.getContext('2d');
        const positions = ["è¿‡å»", "ç°åœ¨", "æœªæ¥"];
        
        // å“åº”å¼Canvaså¤§å°
        function resizeCanvas() {
            // é™åˆ¶æœ€å¤§å®½åº¦ï¼Œä¿æŒçºµæ¨ªæ¯”
            const maxWidth = Math.min(window.innerWidth - 40, 800);
            canvas.width = maxWidth;
            canvas.height = maxWidth * 0.75; // ä¿æŒ4:3æ¯”ä¾‹
            
            // é‡æ–°ç»˜åˆ¶
            draw();
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        // ç‰Œå †å’Œå¡æ§½é…ç½®
        const deckConfig = {
            fanRadius: canvas.width * 0.6,
            fanAngle: Math.PI * 0.3, // 60åº¦çš„æ‰‡å½¢
            cardWidth: canvas.width * 0.11,
            cardHeight: canvas.width * 0.18,
            cardCount: 78,
            centerX: canvas.width / 2,
            centerY: canvas.height * 0.55,
            hoverIndex: -1,
            selectedCards: [],
            slots: [
                {x: canvas.width * 0.25, y: canvas.height * 0.25, filled: false, card: null},
                {x: canvas.width * 0.5, y: canvas.height * 0.25, filled: false, card: null},
                {x: canvas.width * 0.75, y: canvas.height * 0.25, filled: false, card: null}
            ],
            animation: {
                active: false,
                card: null,
                startX: 0,
                startY: 0,
                targetX: 0,
                targetY: 0,
                progress: 0,
                rotating: false,
                scale: 1,
                slotIndex: -1
            }
        };
        
        // ç”Ÿæˆå¡ç‰Œä¿¡æ¯
        function generateDeck() {
            const deck = [];
            for (let i = 0; i < deckConfig.cardCount; i++) {
                const angle = -deckConfig.fanAngle/2 + (deckConfig.fanAngle / (deckConfig.cardCount-1)) * i;
                const x = deckConfig.centerX + Math.cos(angle + Math.PI/2) * deckConfig.fanRadius;
                const y = deckConfig.centerY + Math.sin(angle + Math.PI/2) * deckConfig.fanRadius;
                const rotation = angle;
                
                deck.push({
                    x,
                    y,
                    rotation,
                    width: deckConfig.cardWidth,
                    height: deckConfig.cardHeight,
                    selected: false,
                    tarotInfo: tarotCards[Math.floor(Math.random() * tarotCards.length)]
                });
            }
            return deck;
        }
        
        // å¡ç‰Œæ•°æ®
        const deck = generateDeck();
        
        // ç»˜åˆ¶ç‰ŒèƒŒé¢
        function drawCardBack(x, y, width, height, rotation = 0, scale = 1) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotation);
            ctx.scale(scale, scale);
            
            // å¡ç‰Œå¤–æ¡†
            ctx.fillStyle = '#1F1F3A';
            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;
            roundRect(ctx, -width/2, -height/2, width, height, 10, true);
            
            // å¡ç‰Œå†…æ¡†
            ctx.strokeStyle = 'rgba(215, 170, 100, 0.6)';
            ctx.lineWidth = 2;
            roundRect(ctx, -width/2 + 8, -height/2 + 8, width - 16, height - 16, 6, false, true);
            
            // èŠ±çº¹èƒŒæ™¯
            ctx.fillStyle = '#1F1F3A';
            drawCardPattern(ctx, -width/2, -height/2, width, height);
            
            // ä¸­å¤®æ˜Ÿæ˜Ÿ
            ctx.fillStyle = 'rgba(215, 170, 100, 0.7)';
            ctx.font = `${width/4}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('âœ¦', 0, 0);
            
            ctx.restore();
        }
        
        // ç»˜åˆ¶ç‰Œé¢
        function drawCardFront(x, y, width, height, rotation = 0, scale = 1, card) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotation);
            ctx.scale(scale, scale);
            
            // å¡ç‰ŒèƒŒæ™¯
            const gradient = ctx.createLinearGradient(0, -height/2, 0, height/2);
            gradient.addColorStop(0, '#3a1f7d');
            gradient.addColorStop(1, '#331a5d');
            ctx.fillStyle = gradient;
            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;
            roundRect(ctx, -width/2, -height/2, width, height, 10, true);
            
            // å¡ç‰Œå†…æ¡†
            ctx.strokeStyle = 'rgba(215, 170, 100, 0.6)';
            ctx.lineWidth = 2;
            roundRect(ctx, -width/2 + 8, -height/2 + 8, width - 16, height - 16, 6, false, true);
            
            // ä½ç½®æ–‡æœ¬
            ctx.fillStyle = '#D7AA64';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillText(card.position || '', 0, -height/2 + 20);
            
            // å¡ç‰Œå›¾ç¤ºåŒºåŸŸ
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            roundRect(ctx, -width/4, -height/4, width/2, height/2, 5, true);
            
            // å¡ç‰Œåç§°
            ctx.fillStyle = '#D7AA64';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            ctx.fillText(`${card.tarotInfo.symbol} ${card.tarotInfo.name}`, 0, height/2 - 20);
            
            ctx.restore();
        }
        
        // ç»˜åˆ¶å¡ç‰ŒèŠ±çº¹
        function drawCardPattern(ctx, x, y, width, height) {
            const patternSize = 12;
            ctx.save();
            
            // åˆ›å»ºäº¤å‰çº¿æ¡å›¾æ¡ˆ
            for (let i = 0; i < width; i += patternSize) {
                for (let j = 0; j < height; j += patternSize) {
                    if ((i + j) % (patternSize * 2) === 0) {
                        ctx.fillStyle = 'rgba(59, 38, 103, 0.7)';
                        ctx.fillRect(x + i, y + j, patternSize, patternSize);
                    }
                }
            }
            
            ctx.restore();
        }
        
        // ç»˜åˆ¶åœ†è§’çŸ©å½¢
        function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            if (fill) {
                ctx.fill();
            }
            if (stroke) {
                ctx.stroke();
            }
        }
        
        // ç»˜åˆ¶ç©ºå¡æ§½
        function drawEmptySlot(x, y, width, height) {
            ctx.save();
            ctx.strokeStyle = 'rgba(215, 170, 100, 0.3)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            roundRect(ctx, x - width/2, y - height/2, width, height, 10, false, true);
            ctx.restore();
        }
        
        // ç»˜åˆ¶æ˜Ÿæ˜Ÿ
        function drawStars() {
            const starCount = 50;
            ctx.save();
            
            for (let i = 0; i < starCount; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const size = Math.random() * 2 + 1;
                const opacity = Math.random() * 0.5 + 0.1;
                
                ctx.fillStyle = `rgba(215, 170, 100, ${opacity})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
        }
        
        // ä¸»ç»˜åˆ¶å‡½æ•°
        function draw() {
            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶èƒŒæ™¯æ˜Ÿæ˜Ÿ
            drawStars();
            
            // ç»˜åˆ¶å¡æ§½
            deckConfig.slots.forEach(slot => {
                if (!slot.filled) {
                    drawEmptySlot(slot.x, slot.y, deckConfig.cardWidth, deckConfig.cardHeight);
                }
            });
            
            // ç»˜åˆ¶å·²é€‰æ‹©çš„å¡ç‰Œ
            deckConfig.slots.forEach(slot => {
                if (slot.filled && slot.card) {
                    drawCardFront(slot.x, slot.y, deckConfig.cardWidth, deckConfig.cardHeight, 0, 1, slot.card);
                }
            });
            
            // å¦‚æœæœ‰åŠ¨ç”»æ­£åœ¨è¿›è¡Œ
            if (deckConfig.animation.active) {
                const anim = deckConfig.animation;
                
                // è®¡ç®—å½“å‰ä½ç½®
                const currentX = anim.startX + (anim.targetX - anim.startX) * anim.progress;
                const currentY = anim.startY + (anim.targetY - anim.startY) * anim.progress;
                
                // è®¡ç®—æ—‹è½¬å’Œç¼©æ”¾
                let rotation = 0;
                if (anim.rotating) {
                    // æ—‹è½¬åŠ¨ç”» - ä»0åˆ°PI (180åº¦)
                    rotation = Math.PI * anim.progress;
                }
                
                // ç»˜åˆ¶åŠ¨ç”»ä¸­çš„å¡ç‰Œ
                if (anim.progress < 0.5 || !anim.rotating) {
                    // å‰åŠæ®µåŠ¨ç”»æˆ–è€…æ— éœ€æ—‹è½¬æ—¶ç»˜åˆ¶èƒŒé¢
                    drawCardBack(currentX, currentY, deckConfig.cardWidth, deckConfig.cardHeight, anim.card.rotation, anim.scale);
                } else {
                    // ååŠæ®µåŠ¨ç”»ä¸”éœ€è¦æ—‹è½¬æ—¶ç»˜åˆ¶æ­£é¢
                    drawCardFront(currentX, currentY, deckConfig.cardWidth, deckConfig.cardHeight, 0, anim.scale, anim.card);
                }
                
                // æ›´æ–°åŠ¨ç”»è¿›åº¦
                anim.progress += 0.02;
                
                // åŠ¨ç”»ç»“æŸå¤„ç†
                if (anim.progress >= 1) {
                    anim.active = false;
                    
                    // å¦‚æœéœ€è¦æ”¾å…¥æ’æ§½
                    if (anim.slotIndex >= 0) {
                        const slot = deckConfig.slots[anim.slotIndex];
                        slot.filled = true;
                        slot.card = anim.card;
                        slot.card.position = positions[anim.slotIndex];
                        
                        // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰å¡æ§½éƒ½å·²å¡«æ»¡
                        const allFilled = deckConfig.slots.every(s => s.filled);
                        if (allFilled) {
                            document.getElementById('instructions').textContent = "å·²é€‰æ‹©æ‰€æœ‰å¡”ç½—ç‰Œ";
                            document.getElementById('resultButton').style.display = "block";
                            
                            // æ›´æ–°ç»“æœæŒ‰é’®é“¾æ¥
                            const resultButton = document.getElementById('resultButton');
                            resultButton.addEventListener('click', function() {
                                if (master && question) {
                                    window.location.href = `result.html?master=${master}&question=${encodeURIComponent(question)}&spread=${spread || 'time-flow'}`;
                                }
                            });
                        } else {
                            // æ›´æ–°æŒ‡å¼•æ–‡æœ¬ï¼Œæ˜¾ç¤ºä¸‹ä¸€æ­¥éœ€è¦é€‰æ‹©çš„å¡ç‰Œ
                            const nextSlotIndex = deckConfig.slots.findIndex(s => !s.filled);
                            const nextPosition = positions[nextSlotIndex];
                            document.getElementById('instructions').innerHTML = `è¯·ç»§ç»­é€‰æ‹©ä»£è¡¨<span>${nextPosition}</span>çš„ç‰Œ`;
                        }
                    }
                }
            }
            
            // ç»˜åˆ¶ç‰Œå †
            deck.forEach((card, index) => {
                if (!card.selected) {
                    // é«˜äº®æ‚¬åœçš„ç‰Œ
                    if (index === deckConfig.hoverIndex) {
                        drawCardBack(card.x, card.y - 20, card.width, card.height, card.rotation, 1.1); // ä¸Šç§»å¹¶æ”¾å¤§
                    } else {
                        drawCardBack(card.x, card.y, card.width, card.height, card.rotation);
                    }
                }
            });
            
            // ç»§ç»­åŠ¨ç”»å¾ªç¯
            requestAnimationFrame(draw);
        }
        
        // æ£€æµ‹å¡ç‰Œé¼ æ ‡æ‚¬åœ
        function isPointInCard(x, y, card) {
            const dx = x - card.x;
            const dy = y - card.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // ç®€å•è·ç¦»æ£€æµ‹ï¼Œå¯ä»¥æ ¹æ®éœ€è¦ä¼˜åŒ–
            return distance < card.width / 2;
        }
        
        // é¼ æ ‡ç§»åŠ¨äº‹ä»¶
        canvas.addEventListener('mousemove', function(event) {
            if (deckConfig.animation.active) return; // åŠ¨ç”»ä¸­ä¸å“åº”
            
            const rect = canvas.getBoundingClientRect();
            const x = (event.clientX - rect.left) / (rect.right - rect.left) * canvas.width;
            const y = (event.clientY - rect.top) / (rect.bottom - rect.top) * canvas.height;
            
            // é‡ç½®æ‚¬åœç´¢å¼•
            deckConfig.hoverIndex = -1;
            
            // ä»åå¾€å‰æ£€æµ‹ï¼ˆè§†è§‰ä¸Šçš„æ­£ç¡®é¡ºåºï¼‰
            for (let i = deck.length - 1; i >= 0; i--) {
                if (!deck[i].selected && isPointInCard(x, y, deck[i])) {
                    deckConfig.hoverIndex = i;
                    canvas.style.cursor = 'pointer';
                    break;
                }
            }
            
            if (deckConfig.hoverIndex === -1) {
                canvas.style.cursor = 'default';
            }
        });
        
        // ç‚¹å‡»äº‹ä»¶
        canvas.addEventListener('click', function(event) {
            if (deckConfig.animation.active) return; // åŠ¨ç”»ä¸­ä¸å“åº”
            
            // æ£€æŸ¥æ˜¯å¦è¿˜èƒ½é€‰ç‰Œ
            const filledSlotsCount = deckConfig.slots.filter(s => s.filled).length;
            if (filledSlotsCount >= 3) return; // å·²ç»é€‰æ‹©äº†ä¸‰å¼ ç‰Œ
            
            // æ‰¾å‡ºå½“å‰æ‚¬åœçš„ç‰Œ
            if (deckConfig.hoverIndex !== -1) {
                const selectedCard = deck[deckConfig.hoverIndex];
                selectedCard.selected = true;
                
                // æ‰¾å‡ºç¬¬ä¸€ä¸ªç©ºå¡æ§½
                const slotIndex = deckConfig.slots.findIndex(s => !s.filled);
                if (slotIndex !== -1) {
                    const targetSlot = deckConfig.slots[slotIndex];
                    
                    // è®¾ç½®åŠ¨ç”»å‚æ•°
                    deckConfig.animation.active = true;
                    deckConfig.animation.card = selectedCard;
                    deckConfig.animation.startX = selectedCard.x;
                    deckConfig.animation.startY = selectedCard.y - 20; // ä»æ‚¬åœä½ç½®å¼€å§‹
                    deckConfig.animation.targetX = targetSlot.x;
                    deckConfig.animation.targetY = targetSlot.y;
                    deckConfig.animation.progress = 0;
                    deckConfig.animation.rotating = true;
                    deckConfig.animation.scale = 1;
                    deckConfig.animation.slotIndex = slotIndex;
                }
            }
        });
        
        // å¼€å§‹ç»˜åˆ¶å¾ªç¯
        draw();
    </script>
</body>
</html> 